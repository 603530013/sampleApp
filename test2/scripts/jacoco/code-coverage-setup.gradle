subprojects {
    configurations.all {
        resolutionStrategy {
            // cache dynamic versions for 1 minutes
            cacheDynamicVersionsFor 1 * 60, 'seconds'
            // don't cache changing modules at all
            cacheChangingModulesFor 0, 'seconds'

            eachDependency { details ->
                if ('org.jacoco' == details.requested.group) {
                    details.useVersion "0.8.7"
                }

                if ('org.jacoco.agent' == details.requested.group) {
                    details.useVersion "0.8.7"
                }
            }
        }
    }

    afterEvaluate { project ->

        // ignore container folders
        def projectName = project.name
        // Need to check new project
        // if(projectName == "common" || projectName == "features" || projectName == "gma" || projectName == "actions")
        //    return

        println "Starting coverage variant config script for: $projectName"
        project.apply from: "${rootProject.rootDir}/scripts/jacoco/jacoco-for-variants.gradle"

        android {
            dexOptions {
                javaMaxHeapSize "2048MB"
            }
            buildTypes {
                debug {
                    testCoverageEnabled true
                }
            }

            testOptions {
                unitTests.returnDefaultValues = true
                unitTests.all {
                    jacoco {
                        includeNoLocationClasses = true
                        excludes = ['jdk.internal.*']
                    }
                }
                unitTests.all {
                    setIgnoreFailures(true)
                }
            }
        }
    }
}

apply from: 'scripts/jacoco/jacoco-report.gradle'

task mergeJacocoReport(type: JacocoMerge) {
    group "Jacoco Report"
    description "Merge Jacoco Code Coverage Report"

    println "Merge jacoco Block: $rootProject.rootDir"

    def executionFiles = fileTree("$rootProject.rootDir", {
        includes = ['testDevDebugUnitTest.exec', '**/testDevDebugUnitTest.exec', '**/*.ec']
    })

    executionFiles.each { val ->
        println("Merge: ${val.path} \n")
    }

    setExecutionData(executionFiles)
}
